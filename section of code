; Принимает указатель на строку, пытается
; прочитать из её начала беззнаковое число.
; Возвращает в rax: число, rdx : его длину в символах
; rdx = 0 если число прочитать не удалось
; адрес строки - rdi 
parse_uint:
	xor	rax, rax	    ; обнуляем rax, rsi, r9. rax будет конечным результатом процедуры
	xor	r9, r9			; r9 как счетчик длины
	xor	rsi, rsi		; rsi как буфер для текучей цифры
	mov	r10, 10			; основание числа 
.loop:					;
	mov	rsi, [rdi]		; записывание текучий символ
	inc	rdi			    ; перходим на указывание на другой символ
	cmp	rsi, 0		; проверяем символ на ноль, в аротивном случае прерываем процедуру
	je	.end			;
	sub	rsi, '0'		; переводим код символа в его эквивалент числу
	cmp	rsi, 0			; если код получился больше 9 или меньше 0, то прирываем процедуру
	jl	.end			;
	cmp	rsi, 9			;
	jg	.end			;
	mul	r10			    ;умнажаем rax на 10 и кладем в его конец текучее число
	add	rax, rsi		;
	inc	r9			    ;увеличиваем счетчик длины слова 
	jmp	.loop			;
.end:					;
	mov	rdx, r9			; 
	ret				;







; Принимает указатель на строку, пытается
; прочитать из её начала знаковое число.
; Если есть знак, пробелы между ним и числом не разрешены.
; Возвращает в rax: число, rdx : его длину в символах (включая знак, если он был) 
; rdx = 0 если число прочитать не удалось
parse_int:
	xor	rsi, rsi			; обнуляем rsi
    cmp	byte[rdi], '+'	; проверяем первый символ +
	jne	.pruv
    inc	rdi
    mov rsi, 2     ; отмечаем метку полжительного числа
    jmp .par_int  ;переходим на следующий символ
.pruv:
	cmp	byte[rdi], '-'	; проверяем первый символ -
	jne	.par_int      ; если не оказалось -, то парсим как безнаковое число 
	mov rsi, 1			; отмечаем метку отрицательного числа
	inc	rdi         ; переходим на следующий символ
.par_int:				;
	push	rsi			; сохраняем в стак rsi
	call	parse_uint		; parse unsignen number
	pop	rsi			; возвращаем обратно
	cmp	rdx, 0			; если прочитали никакое число, то просто возвращаем нуль
	je	.return			;
	cmp	rsi, 0			; если отмечена метка отрицательного числа, то преобразаем число в отрицательное
	je	.return			; 
	inc rdx			; увеличивает длину числа
    cmp	rsi, 1			; если отмечена метка отрицательного числа, то преобразаем число в отрицательное
	jne	.return
	neg	rax             ; конвертируем в отрицательное число 

.return:
	ret
